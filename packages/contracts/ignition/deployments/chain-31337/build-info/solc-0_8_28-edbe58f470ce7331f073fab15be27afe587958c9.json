{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-edbe58f470ce7331f073fab15be27afe587958c9",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ProofOfMe.sol": "project/contracts/ProofOfMe.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/ProofOfMe.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\ninterface IENS {\n    function resolver(bytes32 node) external view returns (address);\n\n    function owner(bytes32 node) external view returns (address);\n}\n\ninterface IENSResolver {\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view returns (string memory);\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool);\n}\n\n/**\n * @title ProofOfMe\n * @dev contract to attach DID claims to ENS names\n * @author Ishola\n */\ncontract ProofOfMe {\n    // ENS registry on mainnet\n    IENS public constant ENS_REGISTRY =\n        IENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\n\n    // ProofOfMe text record key\n    string public constant PROOFOFME_KEY = \"proofofme:registry\";\n\n    // Address of the Filecoin claims registry contract\n    address public immutable FILECOIN_CONTRACT;\n\n    // Domain for signature verification\n    uint256 public constant CHAIN_ID = 1; // Ethereum mainnet\n\n    constructor(address _filecoinContract) {\n        require(\n            _filecoinContract != address(0),\n            \"Invalid Filecoin contract address\"\n        );\n        FILECOIN_CONTRACT = _filecoinContract;\n    }\n\n    // Events\n    event DIDClaimed(\n        bytes32 indexed node,\n        string indexed ensName,\n        string didRecord,\n        address indexed claimer\n    );\n\n    event ClaimMessageGenerated(\n        bytes32 indexed node,\n        string indexed ensName,\n        bytes32 indexed messageHash,\n        address claimer\n    );\n\n    // Errors\n    error NotENSOwner(bytes32 node, address caller);\n    error ResolverNotFound(bytes32 node);\n    error EmptyENSName();\n    error DIDAlreadyExists(bytes32 node);\n    error DIDNotRegistered(bytes32 node);\n\n    /**\n     * @dev Generate a signed message for registering DID on Filecoin (first time)\n     * @param ensName The ENS name\n     * @return messageHash The hash that needs to be signed\n     */\n    function generateRegistrationMessage(\n        string calldata ensName\n    ) external view returns (bytes32 messageHash) {\n        if (bytes(ensName).length == 0) revert EmptyENSName();\n\n        bytes32 node = _namehash(ensName);\n\n        // Verify caller owns the ENS name\n        if (ENS_REGISTRY.owner(node) != msg.sender) {\n            revert NotENSOwner(node, msg.sender);\n        }\n\n        // Check if DID exists\n        if (!hasDID(ensName)) {\n            revert DIDNotRegistered(node);\n        }\n\n        // Construct the DID\n        string memory did = string(abi.encodePacked(PROOFOFME_KEY, ensName));\n\n        // Create message hash for Filecoin contract signature\n        messageHash = keccak256(\n            abi.encodePacked(\"Register\", did, FILECOIN_CONTRACT)\n        );\n\n        return messageHash;\n    }\n\n    /**\n     * @dev Register a DID for an ENS name\n     * @param ensName The ENS name\n     */\n    function registerDID(\n        string calldata ensName\n    ) external returns (bytes32 messageHash) {\n        if (bytes(ensName).length == 0) revert EmptyENSName();\n\n        bytes32 node = _namehash(ensName);\n\n        // Verify caller owns the ENS name\n        if (ENS_REGISTRY.owner(node) != msg.sender) {\n            revert NotENSOwner(node, msg.sender);\n        }\n\n        // Get the resolver\n        address resolverAddr = ENS_REGISTRY.resolver(node);\n        if (resolverAddr == address(0)) revert ResolverNotFound(node);\n\n        IENSResolver resolver = IENSResolver(resolverAddr);\n\n        // Check if DID already exists\n        string memory existingDID = resolver.text(node, PROOFOFME_KEY);\n        if (bytes(existingDID).length > 0) {\n            revert DIDAlreadyExists(node);\n        }\n\n        // Construct the record: \"did:ensName\"\n        string memory didRecord = string(abi.encodePacked(\"did:\", ensName));\n\n        // Set the text record\n        resolver.setText(node, PROOFOFME_KEY, didRecord);\n        emit DIDClaimed(node, ensName, didRecord, msg.sender);\n        bytes32 results = this.generateRegistrationMessage(ensName);\n        emit ClaimMessageGenerated(node, ensName, results, msg.sender);\n        return messageHash;\n    }\n\n    /**\n     * @dev Generate a signed message for adding a claim to Filecoin\n     * @param ensName The ENS name\n     * @param cid The CID of the claim data on IPFS/Filecoin\n     * @param credentialName The type of claim (e.g., \"ghana-card\", \"ghana-passport\")\n     * @return messageHash The hash that needs to be signed\n     */\n    function generateClaimMessage(\n        string calldata ensName,\n        string calldata cid,\n        string calldata credentialName\n    ) external view returns (bytes32 messageHash) {\n        if (bytes(ensName).length == 0) revert EmptyENSName();\n\n        bytes32 node = _namehash(ensName);\n\n        // Verify caller owns the ENS name\n        if (ENS_REGISTRY.owner(node) != msg.sender) {\n            revert NotENSOwner(node, msg.sender);\n        }\n\n        // Check if DID exists\n        if (!hasDID(ensName)) {\n            revert DIDNotRegistered(node);\n        }\n\n        // Construct the DID\n        string memory did = string(abi.encodePacked(PROOFOFME_KEY, ensName));\n\n        // Create message hash for Filecoin contract signature\n        // This should match the format expected by DIDClaimsRegistry\n        messageHash = keccak256(\n            abi.encodePacked(\n                \"IssueClaim\",\n                did,\n                cid,\n                credentialName,\n                FILECOIN_CONTRACT\n            )\n        );\n        return messageHash;\n    }\n\n    /**\n     * @dev Get DID record for an ENS name\n     * @param ensName The ENS name\n     * @return The DID record or empty string if not set\n     */\n    function getDID(\n        string calldata ensName\n    ) external view returns (string memory) {\n        if (bytes(ensName).length == 0) return \"\";\n\n        bytes32 node = _namehash(ensName);\n        address resolverAddr = ENS_REGISTRY.resolver(node);\n\n        if (resolverAddr == address(0)) return \"\";\n\n        IENSResolver resolver = IENSResolver(resolverAddr);\n        return resolver.text(node, PROOFOFME_KEY);\n    }\n\n    /**\n     * @dev Check if an ENS name has a DID record\n     * @param ensName The ENS name\n     * @return True if DID exists, false otherwise\n     */\n    function hasDID(string calldata ensName) public view returns (bool) {\n        if (bytes(ensName).length == 0) return false;\n\n        bytes32 node = _namehash(ensName);\n        address resolverAddr = ENS_REGISTRY.resolver(node);\n\n        if (resolverAddr == address(0)) return false;\n\n        IENSResolver resolver = IENSResolver(resolverAddr);\n        string memory didRecord = resolver.text(node, PROOFOFME_KEY);\n\n        return bytes(didRecord).length > 0;\n    }\n\n    /**\n     * @dev Get the namehash of an ENS name\n     * @param name The ENS name\n     * @return The namehash as bytes32\n     */\n    function getNamehash(string calldata name) external pure returns (bytes32) {\n        return _namehash(name);\n    }\n\n    /**\n     * @dev Internal function to compute ENS namehash\n     * @param name The ENS name (e.g., \"vitalik.eth\")\n     * @return The namehash\n     */\n    function _namehash(string memory name) internal pure returns (bytes32) {\n        bytes32 node = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n        if (bytes(name).length == 0) {\n            return node;\n        }\n\n        // Split by dots and hash each label\n        bytes memory nameBytes = bytes(name);\n        uint256 len = nameBytes.length;\n\n        // Start from the end and work backwards\n        bytes32[] memory labels = new bytes32[](10); // Max 10 levels deep\n        uint256 labelCount = 0;\n        uint256 start = len;\n\n        // Parse labels from right to left\n        for (uint256 i = len; i > 0; i--) {\n            if (nameBytes[i - 1] == 0x2e || i == 1) {\n                // 0x2e is '.'\n                uint256 labelStart = (nameBytes[i - 1] == 0x2e) ? i : 0;\n                uint256 labelLen = start - labelStart;\n\n                if (labelLen > 0) {\n                    bytes memory label = new bytes(labelLen);\n                    for (uint256 j = 0; j < labelLen; j++) {\n                        label[j] = nameBytes[labelStart + j];\n                    }\n                    labels[labelCount] = keccak256(label);\n                    labelCount++;\n                }\n                start = labelStart;\n            }\n        }\n\n        // Compute namehash from left to right\n        for (uint256 i = labelCount; i > 0; i--) {\n            node = keccak256(abi.encodePacked(node, labels[i - 1]));\n        }\n\n        return node;\n    }\n}\n"
      }
    }
  }
}